    int H = min_i32(builder->height, dst->height);
    int W = min_i32(builder->width, dst->width);

    // Second pass: smart blur to get sub-frame precision on timing values
    // This converges to smooth gradients while respecting envelope error bars

    // Create smart blur contexts for attack (key press) and release (key release) timing
    SmartBlurContext* attack_blur = sb_Initialize(W, H);
    SmartBlurContext* release_blur = sb_Initialize(W, H);

    if (!attack_blur || !release_blur) {
        printf("Failed to allocate smart blur contexts\n");
        sb_Free(attack_blur);
        sb_Free(release_blur);
        return -1;
    }

    // Set constraints for each pixel based on envelope error bars
    for (int y = 0; y < H; y++) {
        for (int x = 0; x < W; x++) {
            int idx = (y * builder->width + x);
            struct PixelState* pixel = &builder->pixels[idx];

            if (pixel->has_best) {
                // Attack timing: error bars are [attack_start, attack_end]
                float attack_min = (float)pixel->best.attack_start;
                float attack_max = (float)pixel->best.attack_end;
                float attack_initial = (attack_min + attack_max) / 2.0f;

                // Release timing: error bars are [release_start, release_end]
                float release_min = (float)pixel->best.release_start;
                float release_max = (float)pixel->best.release_end;
                float release_initial = (release_min + release_max) / 2.0f;

                sb_SetConstraints(attack_blur, x, y, attack_min, attack_max, attack_initial);
                sb_SetConstraints(release_blur, x, y, release_min, release_max, release_initial);
            } else {
                // No envelope - set invalid constraints
                sb_SetConstraints(attack_blur, x, y, 1.0f, -1.0f, 0.0f);
                sb_SetConstraints(release_blur, x, y, 1.0f, -1.0f, 0.0f);
            }
        }
    }

    // Run smart blur until converged
    int attack_iters = sb_RunUntilConverged(attack_blur, 0.01f, 1000);
    int release_iters = sb_RunUntilConverged(release_blur, 0.01f, 1000);

    printf("Smart blur converged: attack in %d iterations, release in %d iterations\n", attack_iters, release_iters);

    // Third pass: write texture using converged values
    for (int y = 0; y < H; y++) {
        for (int x = 0; x < W; x++) {
            int idx = (y * builder->width + x);
            struct PixelState* pixel = &builder->pixels[idx];

            int dst_idx = (y * dst->width + x) * 4;

            if (pixel->has_best == 0) {
                *(uint32_t*)(&dst->data[dst_idx]) = 0xFF000000;
            } else {
                // Get converged timing values
                float attack_frame = sb_GetValue(attack_blur, x, y);
                float release_frame = sb_GetValue(release_blur, x, y);

                // Normalize to [0, 1] range
                float attack_norm = (attack_frame - m.min_attack_frame) / attack_duration;
                float release_norm = (release_frame - m.min_release_frame) / release_duration;

                // B: Edge hardness based on attack/release speed
                delta_alpha = (pixel->best.max_alpha - pixel->best.min_attack_alpha);
                float attack_speed = delta_alpha / max_f32(1.0f, pixel->best.attack_end - pixel->best.attack_start);

                delta_alpha = (pixel->best.max_alpha - pixel->best.min_release_alpha);
                float release_speed = delta_alpha / max_f32(1.0f, pixel->best.release_end - pixel->best.release_start);

                float attack_softness = 1.0f - (attack_speed * (m.max_attack_frame - m.min_attack_frame) / (15.0f * m.total_frames));
                float release_softness = 1.0f - (release_speed * (m.max_release_frame - m.min_release_frame) / (15.0f * m.total_frames));

                float softness = min_f32(attack_softness, release_softness);

                // R: Inverted normalized attack timing (for shader)
                dst->data[dst_idx + 0] = (uint8_t)clamp_i32((1.0f - attack_norm) * 255, 0, 255);
                // G: Normalized release timing
                dst->data[dst_idx + 1] = (uint8_t)clamp_i32(release_norm * 255, 0, 255);
                // B: Edge softness
                dst->data[dst_idx + 2] = (uint8_t)clamp_i32(softness * 255, 0, 255);
                // A: Full opacity for valid pixels
                dst->data[dst_idx + 3] = 255;
            }
        }
    }

    // Cleanup
    sb_Free(attack_blur);
    sb_Free(release_blur);

